// Copyright Â© 2020 - 2022 Attestant Limited.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package golang_test

import (
	"context"
	"fmt"
	"os"
	"runtime"
	"sync"
	"sync/atomic"
	"testing"

	"github.com/attestantio/dirk/rules"
	standardrules "github.com/attestantio/dirk/rules/standard"
	"github.com/attestantio/dirk/services/checker"
	syncmaplocker "github.com/attestantio/dirk/services/locker/syncmap"
	"github.com/attestantio/dirk/services/ruler"
	"github.com/attestantio/dirk/services/ruler/golang"
	"github.com/attestantio/dirk/testing/logger"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	e2types "github.com/wealdtech/go-eth2-types/v2"
)

func TestRunRules(t *testing.T) {
	tests := []struct {
		name        string
		credentials *checker.Credentials
		action      string
		data        []*ruler.RulesData
		results     []rules.Result
		logEntry    string
	}{
		{
			name:     "Nil",
			results:  []rules.Result{rules.FAILED},
			logEntry: "Received no rules data entries",
		},
		{
			name:     "Empty",
			data:     []*ruler.RulesData{},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Received no rules data entries",
		},
		{
			name: "DataNil",
			data: []*ruler.RulesData{
				nil,
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Received nil rules data",
		},
		{
			name: "DataEmpty",
			data: []*ruler.RulesData{
				{},
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Received nil data in rules data",
		},
		{
			name: "DataDataNil",
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
				},
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Received nil data in rules data",
		},
		{
			name:   "DataPubKeyNil",
			action: ruler.ActionSign,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Received no pubkey in rules data",
		},
		{
			name:   "DataPubKeyEmpty",
			action: ruler.ActionSign,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey:      []byte{},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Received no pubkey in rules data",
		},
		{
			name:   "CredentialsNil",
			action: ruler.ActionSign,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Failed to assemble metadata",
		},
		{
			name:   "CredentialsEmpty",
			action: ruler.ActionSign,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			credentials: &checker.Credentials{},
			results:     []rules.Result{rules.FAILED},
			logEntry:    "Failed to assemble metadata",
		},
		{
			name:   "CredentialsClientEmpty",
			action: ruler.ActionSign,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "",
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Failed to assemble metadata",
		},
		{
			name: "ActionEmpty",
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "access",
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Unknown action",
		},
		{
			name:   "ActionBad",
			action: "unknown",
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "access",
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Unknown action",
		},
		{
			name:   "ActionDataIncorrect",
			action: ruler.ActionAccessAccount,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "access",
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "PubKeyDuplicated",
			action: ruler.ActionSign,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
				{
					WalletName:  "wallet",
					AccountName: "account2",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "sign",
			},
			results:  []rules.Result{rules.UNKNOWN, rules.FAILED},
			logEntry: "Multiple requests for same key",
		},
		{
			name:   "SignData2Bad",
			action: ruler.ActionSign,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "sign",
			},
			results:  []rules.Result{rules.APPROVED, rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "SignGood",
			action: ruler.ActionSign,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignData{
						Domain: []byte{
							0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Data: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "sign",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
		{
			name:   "SignBeaconProposalData2Bad",
			action: ruler.ActionSignBeaconProposal,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconProposalData{
						Domain: []byte{
							0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:          5,
						ProposerIndex: 6,
						ParentRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						StateRoot: []byte{
							0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
							0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
						},
						BodyRoot: []byte{
							0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
							0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
						},
					},
				},
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "sign",
			},
			results:  []rules.Result{rules.APPROVED, rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "SignBeaconProposalGood",
			action: ruler.ActionSignBeaconProposal,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconProposalData{
						Domain: []byte{
							0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:          5,
						ProposerIndex: 6,
						ParentRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						StateRoot: []byte{
							0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
							0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
						},
						BodyRoot: []byte{
							0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
							0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
						},
					},
				},
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconProposalData{
						Domain: []byte{
							0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:          5,
						ProposerIndex: 6,
						ParentRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						StateRoot: []byte{
							0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
							0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
						},
						BodyRoot: []byte{
							0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
							0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "signbeaconproposal",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
		{
			name:   "SignBeaconAttestationDataBad",
			action: ruler.ActionSignBeaconAttestation,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "signbeaconattestation",
			},
			results:  []rules.Result{rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "SignBeaconAttestationData2Bad",
			action: ruler.ActionSignBeaconAttestation,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconAttestationData{
						Domain: []byte{
							0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:           5,
						CommitteeIndex: 1,
						BeaconBlockRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						Source: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
								0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
							},
						},
						Target: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
								0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
							},
						},
					},
				},
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "signbeaconattestation",
			},
			results:  []rules.Result{rules.UNKNOWN, rules.FAILED},
			logEntry: "Data is not for signing beacon attestation",
		},
		{
			name:   "SignBeaconAttestationGood",
			action: ruler.ActionSignBeaconAttestation,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconAttestationData{
						Domain: []byte{
							0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:           5,
						CommitteeIndex: 1,
						BeaconBlockRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						Source: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
								0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
							},
						},
						Target: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
								0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
							},
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "signbeaconattestation",
			},
			results: []rules.Result{rules.APPROVED},
		},
		{
			name:   "SignBeaconAttestationMultipleNoCredentials",
			action: ruler.ActionSignBeaconAttestation,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconAttestationData{
						Domain: []byte{
							0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:           5,
						CommitteeIndex: 1,
						BeaconBlockRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						Source: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
								0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
							},
						},
						Target: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
								0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
							},
						},
					},
				},
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconAttestationData{
						Domain: []byte{
							0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:           5,
						CommitteeIndex: 1,
						BeaconBlockRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						Source: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
								0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
							},
						},
						Target: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
								0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
							},
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "",
			},
			results:  []rules.Result{rules.FAILED, rules.FAILED},
			logEntry: "Failed to assemble metadata",
		},
		{
			name:   "SignBeaconAttestationsMultipleNoAccount",
			action: ruler.ActionSignBeaconAttestation,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconAttestationData{
						Domain: []byte{
							0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:           5,
						CommitteeIndex: 1,
						BeaconBlockRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						Source: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
								0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
							},
						},
						Target: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
								0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
							},
						},
					},
				},
				{
					WalletName: "wallet",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconAttestationData{
						Domain: []byte{
							0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:           5,
						CommitteeIndex: 1,
						BeaconBlockRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						Source: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
								0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
							},
						},
						Target: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
								0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
							},
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "signbeaconattestation",
			},
			results:  []rules.Result{rules.UNKNOWN, rules.FAILED},
			logEntry: "Missing account",
		},
		{
			name:   "SignBeaconAttestationMultipleGood",
			action: ruler.ActionSignBeaconAttestation,
			data: []*ruler.RulesData{
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconAttestationData{
						Domain: []byte{
							0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:           5,
						CommitteeIndex: 1,
						BeaconBlockRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						Source: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
								0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
							},
						},
						Target: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
								0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
							},
						},
					},
				},
				{
					WalletName:  "wallet",
					AccountName: "account",
					PubKey: []byte{
						0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
						0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
					},
					Data: &rules.SignBeaconAttestationData{
						Domain: []byte{
							0x01, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
						},
						Slot:           5,
						CommitteeIndex: 1,
						BeaconBlockRoot: []byte{
							0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
							0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
						},
						Source: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
								0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
							},
						},
						Target: &rules.Checkpoint{
							Epoch: 0,
							Root: []byte{
								0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
								0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
							},
						},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "signbeaconattestation",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
		{
			name:   "AccessAccountData2Bad",
			action: ruler.ActionAccessAccount,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data: &rules.AccessAccountData{
						Paths: []string{"wallet/account1"},
					},
				},
				{
					WalletName: "wallet",
					Data:       &rules.LockAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "accessaccount",
			},
			results:  []rules.Result{rules.APPROVED, rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "AccessAccountGood",
			action: ruler.ActionAccessAccount,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data: &rules.AccessAccountData{
						Paths: []string{"wallet/account1"},
					},
				},
				{
					WalletName: "wallet",
					Data: &rules.AccessAccountData{
						Paths: []string{"wallet/account2"},
					},
				},
			},
			credentials: &checker.Credentials{
				Client: "accessaccount",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
		{
			name:   "UnlockWalletData2Bad",
			action: ruler.ActionUnlockWallet,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.UnlockWalletData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "unlockwallet",
			},
			results:  []rules.Result{rules.APPROVED, rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "UnlockWalletGood",
			action: ruler.ActionUnlockWallet,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.UnlockWalletData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.UnlockWalletData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "unlockwallet",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
		{
			name:   "LockWalletData2Bad",
			action: ruler.ActionLockWallet,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.LockWalletData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "unlockwallet",
			},
			results:  []rules.Result{rules.APPROVED, rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "LockWalletGood",
			action: ruler.ActionLockWallet,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.LockWalletData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.LockWalletData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "unlockwallet",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
		{
			name:   "UnlockAccountData2Bad",
			action: ruler.ActionUnlockAccount,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.UnlockAccountData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "unlockaccount",
			},
			results:  []rules.Result{rules.APPROVED, rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "UnlockAccountGood",
			action: ruler.ActionUnlockAccount,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.UnlockAccountData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.UnlockAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "unlockaccount",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
		{
			name:   "LockAccountData2Bad",
			action: ruler.ActionLockAccount,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.LockAccountData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "lockaccount",
			},
			results:  []rules.Result{rules.APPROVED, rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "LockAccountGood",
			action: ruler.ActionLockAccount,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.LockAccountData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.LockAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "lockaccount",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
		{
			name:   "CreateAccountData2Bad",
			action: ruler.ActionCreateAccount,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.CreateAccountData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.AccessAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "createaccount",
			},
			results:  []rules.Result{rules.APPROVED, rules.FAILED},
			logEntry: "Data not of expected type",
		},
		{
			name:   "CreateAccountGood",
			action: ruler.ActionCreateAccount,
			data: []*ruler.RulesData{
				{
					WalletName: "wallet",
					Data:       &rules.CreateAccountData{},
				},
				{
					WalletName: "wallet",
					Data:       &rules.CreateAccountData{},
				},
			},
			credentials: &checker.Credentials{
				Client: "createaccount",
			},
			results: []rules.Result{rules.APPROVED, rules.APPROVED},
		},
	}

	ctx := context.Background()

	locker, err := syncmaplocker.New(ctx)
	require.NoError(t, err)

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			capture := logger.NewLogCapture()
			storagePath, err := os.MkdirTemp("", "")
			require.NoError(t, err)
			defer os.RemoveAll(storagePath)
			testRules, err := standardrules.New(ctx,
				standardrules.WithStoragePath(storagePath),
			)
			require.NoError(t, err)
			service, err := golang.New(ctx,
				golang.WithLocker(locker),
				golang.WithRules(testRules))
			require.NoError(t, err)
			results := service.RunRules(ctx, test.credentials, test.action, test.data)
			require.Equal(t, test.results, results)
			if test.logEntry != "" {
				capture.AssertHasEntry(t, test.logEntry)
			}
		})
	}
}

func TestRunRulesSignBeaconAttestationSoak(t *testing.T) {
	zerolog.SetGlobalLevel(zerolog.Disabled)
	ctx := context.Background()

	locker, err := syncmaplocker.New(ctx)
	require.NoError(t, err)

	storagePath, err := os.MkdirTemp("", "")
	require.NoError(t, err)
	defer os.RemoveAll(storagePath)
	testRules, err := standardrules.New(ctx,
		standardrules.WithStoragePath(storagePath),
	)
	require.NoError(t, err)
	service, err := golang.New(ctx,
		golang.WithLocker(locker),
		golang.WithRules(testRules))
	require.NoError(t, err)

	// The soak test will create a number of goroutines that will all attempt to sign an attestation at the same time,
	// albeit with different data.  This should result in 1 success and the result denied.

	require.NoError(t, e2types.InitBLS())
	privKey, err := e2types.GenerateBLSPrivateKey()
	require.NoError(t, err)
	pubKey := privKey.PublicKey().Marshal()

	// p is parallelism.
	p := 64
	runtime.GOMAXPROCS(2 * p)
	requests := make([]*rules.SignBeaconAttestationData, p)
	for i := 0; i < p; i++ {
		requests[i] = &rules.SignBeaconAttestationData{
			Domain:          []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			CommitteeIndex:  uint64(i),
			BeaconBlockRoot: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			Source: &rules.Checkpoint{
				Epoch: 5,
				Root:  []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			Target: &rules.Checkpoint{
				Epoch: 6,
				Root:  []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
		}
	}

	// Run for 256 slots.
	for curSlot := uint64(10000); curSlot < uint64(10256); curSlot++ {
		// Set up the slot-specific data.
		for i := 0; i < p; i++ {
			requests[i].Slot = curSlot
			requests[i].Source.Epoch++
			requests[i].Target.Epoch++
		}

		// Set up the counts.
		approved := uint32(0)
		denied := uint32(0)

		credentials := &checker.Credentials{
			Client: "client-test01",
		}
		// Run simultaneously (as near as we can manage).
		var wg sync.WaitGroup
		starter := make(chan interface{})
		for i := 0; i < p; i++ {
			wg.Add(1)
			go func(index int) {
				<-starter
				defer wg.Done()
				rulesData := []*ruler.RulesData{
					{
						WalletName:  "Test wallet",
						AccountName: "Test account",
						PubKey:      pubKey,
						Data:        requests[index],
					},
				}
				res := service.RunRules(context.Background(), credentials, ruler.ActionSignBeaconAttestation, rulesData)
				if res[0] == rules.APPROVED {
					atomic.AddUint32(&approved, 1)
				}
				if res[0] == rules.DENIED {
					atomic.AddUint32(&denied, 1)
				}
			}(i)
		}
		close(starter)
		wg.Wait()
		assert.Equal(t, uint32(1), approved, fmt.Sprintf("Incorrect approvals for slot %d", curSlot))
		assert.Equal(t, uint32(p-1), denied, fmt.Sprintf("Incorrect denials for slot %d", curSlot))
	}
}

func TestRunRulesSignBeaconAttestationsSoak(t *testing.T) {
	zerolog.SetGlobalLevel(zerolog.Disabled)
	ctx := context.Background()

	locker, err := syncmaplocker.New(ctx)
	require.NoError(t, err)

	storagePath, err := os.MkdirTemp("", "")
	require.NoError(t, err)
	defer os.RemoveAll(storagePath)
	testRules, err := standardrules.New(ctx,
		standardrules.WithStoragePath(storagePath),
	)
	require.NoError(t, err)
	service, err := golang.New(ctx,
		golang.WithLocker(locker),
		golang.WithRules(testRules))
	require.NoError(t, err)

	// The soak test will create a number of goroutines that will all attempt to sign an attestation at the same time,
	// albeit with different data.  This should result in 1 success and the result denied.
	// Each data carries 128 signing requests within it.

	// p is parallelism.
	p := 64
	runtime.GOMAXPROCS(2 * p)
	// q is number of attestations per request.
	q := 32

	require.NoError(t, e2types.InitBLS())
	pubKeys := make([][]byte, q)
	for i := 0; i < q; i++ {
		privKey, err := e2types.GenerateBLSPrivateKey()
		require.NoError(t, err)
		pubKeys[i] = privKey.PublicKey().Marshal()
	}

	requests := make([]*rules.SignBeaconAttestationData, p*q)
	for i := 0; i < p*q; i++ {
		requests[i] = &rules.SignBeaconAttestationData{
			Domain:          []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			CommitteeIndex:  uint64(i),
			BeaconBlockRoot: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			Source: &rules.Checkpoint{
				Epoch: 5,
				Root:  []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			Target: &rules.Checkpoint{
				Epoch: 6,
				Root:  []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
		}
	}

	// Run for 32 slots.
	for curSlot := uint64(10032); curSlot < uint64(10032); curSlot++ {
		// Set up the slot-specific data.
		for i := 0; i < p*q; i++ {
			requests[i].Slot = curSlot
			requests[i].Source.Epoch++
			requests[i].Target.Epoch++
		}

		// Set up the counts.
		approved := uint32(0)
		denied := uint32(0)

		credentials := &checker.Credentials{
			Client: "client-test01",
		}
		// Run simultaneously (as near as we can manage).
		var wg sync.WaitGroup
		starter := make(chan interface{})
		for i := 0; i < p; i++ {
			wg.Add(1)
			go func(i int) {
				<-starter
				defer wg.Done()
				rulesData := make([]*ruler.RulesData, q)
				for j := 0; j < q; j++ {
					rulesData[j] = &ruler.RulesData{
						WalletName:  "Test wallet",
						AccountName: "Test account",
						PubKey:      pubKeys[j],
						Data:        requests[i*q+j],
					}
				}
				res := service.RunRules(context.Background(), credentials, ruler.ActionSignBeaconAttestation, rulesData)
				for j := 0; j < q; j++ {
					if res[j] == rules.APPROVED {
						atomic.AddUint32(&approved, 1)
					}
					if res[j] == rules.DENIED {
						atomic.AddUint32(&denied, 1)
					}
				}
			}(i)
		}
		close(starter)
		wg.Wait()
		assert.Equal(t, q, int(approved), fmt.Sprintf("Incorrect approvals for slot %d", curSlot))
		assert.Equal(t, (p-1)*q, int(denied), fmt.Sprintf("Incorrect denials for slot %d", curSlot))
	}
}

func TestRunRulesSignBeaconProposalSoak(t *testing.T) {
	zerolog.SetGlobalLevel(zerolog.Disabled)
	ctx := context.Background()

	locker, err := syncmaplocker.New(ctx)
	require.NoError(t, err)

	storagePath, err := os.MkdirTemp("", "")
	require.NoError(t, err)
	defer os.RemoveAll(storagePath)
	testRules, err := standardrules.New(ctx,
		standardrules.WithStoragePath(storagePath),
	)
	require.NoError(t, err)
	service, err := golang.New(ctx,
		golang.WithLocker(locker),
		golang.WithRules(testRules))
	require.NoError(t, err)

	// The soak test will create a number of goroutines that will all attempt to sign an attestation at the same time,
	// albeit with different data.  This should result in 1 success and the result denied.

	require.NoError(t, e2types.InitBLS())
	privKey, err := e2types.GenerateBLSPrivateKey()
	require.NoError(t, err)
	pubKey := privKey.PublicKey().Marshal()

	// p is parallelism.
	p := 64
	runtime.GOMAXPROCS(2 * p)
	requests := make([]*rules.SignBeaconProposalData, p)
	for i := 0; i < p; i++ {
		requests[i] = &rules.SignBeaconProposalData{
			Domain:        []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			ProposerIndex: 1,
			ParentRoot:    []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			StateRoot:     []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			BodyRoot:      []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		}
	}

	// Run for 256 slots.
	for curSlot := uint64(10000); curSlot < uint64(10256); curSlot++ {
		// Set up the slot-specific data.
		for i := 0; i < p; i++ {
			requests[i].Slot = curSlot
		}

		// Set up the counts.
		approved := uint32(0)
		denied := uint32(0)

		credentials := &checker.Credentials{
			Client: "client-test01",
		}
		// Run simultaneously (as near as we can manage).
		var wg sync.WaitGroup
		starter := make(chan interface{})
		for i := 0; i < p; i++ {
			wg.Add(1)
			go func(index int) {
				<-starter
				defer wg.Done()
				rulesData := []*ruler.RulesData{
					{
						WalletName:  "Test wallet",
						AccountName: "Test account",
						PubKey:      pubKey,
						Data:        requests[index],
					},
				}
				res := service.RunRules(context.Background(), credentials, ruler.ActionSignBeaconProposal, rulesData)
				if res[0] == rules.APPROVED {
					atomic.AddUint32(&approved, 1)
				}
				if res[0] == rules.DENIED {
					atomic.AddUint32(&denied, 1)
				}
			}(i)
		}
		close(starter)
		wg.Wait()
		assert.Equal(t, uint32(1), approved, fmt.Sprintf("Incorrect approvals for slot %d", curSlot))
		assert.Equal(t, uint32(p-1), denied, fmt.Sprintf("Incorrect denials for slot %d", curSlot))
	}
}
